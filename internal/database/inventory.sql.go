// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const batchUpdateRoomTypeInventory = `-- name: BatchUpdateRoomTypeInventory :execrows
INSERT INTO
	booking.room_type_inventory (
		hotel_id,
		room_type_id,
		date,
		total_inventory,
		total_reserved,
		updated_at,
		created_at
	)
SELECT
	$1,
	$2,
	unnest($3),
	$4,
	0,
	CURRENT_TIMESTAMP,
	CURRENT_TIMESTAMP
	--  simplification of a business rule to not handle constantly changing overcapacity issue-> e.g. some rolling update in the future is possible
	ON CONFLICT (hotel_id, room_type_id, date)
DO NOTHING
`

type BatchUpdateRoomTypeInventoryParams struct {
	HotelID        uuid.UUID   `json:"hotel_id"`
	RoomTypeID     uuid.UUID   `json:"room_type_id"`
	Dates          interface{} `json:"dates"`
	TotalInventory int32       `json:"total_inventory"`
}

func (q *Queries) BatchUpdateRoomTypeInventory(ctx context.Context, arg BatchUpdateRoomTypeInventoryParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, batchUpdateRoomTypeInventory,
		arg.HotelID,
		arg.RoomTypeID,
		arg.Dates,
		arg.TotalInventory,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getHotelInventoryForRange = `-- name: GetHotelInventoryForRange :many
SELECT
	hotel_id, room_type_id, date, updated_at, created_at, version, total_inventory, total_reserved
FROM
	booking.room_type_inventory
WHERE
	room_type_id = $1
	AND hotel_id = $2
	AND date BETWEEN $3 AND $4
`

type GetHotelInventoryForRangeParams struct {
	RoomTypeID uuid.UUID `json:"room_type_id"`
	HotelID    uuid.UUID `json:"hotel_id"`
	Date       time.Time `json:"date"`
	Date_2     time.Time `json:"date_2"`
}

func (q *Queries) GetHotelInventoryForRange(ctx context.Context, arg GetHotelInventoryForRangeParams) ([]BookingRoomTypeInventory, error) {
	rows, err := q.db.QueryContext(ctx, getHotelInventoryForRange,
		arg.RoomTypeID,
		arg.HotelID,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookingRoomTypeInventory
	for rows.Next() {
		var i BookingRoomTypeInventory
		if err := rows.Scan(
			&i.HotelID,
			&i.RoomTypeID,
			&i.Date,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Version,
			&i.TotalInventory,
			&i.TotalReserved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoomTypeInventoryForDate = `-- name: UpdateRoomTypeInventoryForDate :execrows
UPDATE booking.room_type_inventory
SET
	total_reserved = total_reserved + $1,
	version = version + 1,
	updated_at = CURRENT_TIMESTAMP
WHERE
	room_type_id = $2
	AND hotel_id = $3
	AND date = $4
	AND version = $5
`

type UpdateRoomTypeInventoryForDateParams struct {
	TotalReserved int32     `json:"total_reserved"`
	RoomTypeID    uuid.UUID `json:"room_type_id"`
	HotelID       uuid.UUID `json:"hotel_id"`
	Date          time.Time `json:"date"`
	Version       int64     `json:"version"`
}

func (q *Queries) UpdateRoomTypeInventoryForDate(ctx context.Context, arg UpdateRoomTypeInventoryForDateParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateRoomTypeInventoryForDate,
		arg.TotalReserved,
		arg.RoomTypeID,
		arg.HotelID,
		arg.Date,
		arg.Version,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
