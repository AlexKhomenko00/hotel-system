// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: inventory.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const batchUpdateRoomTypeInventory = `-- name: BatchUpdateRoomTypeInventory :execrows
INSERT INTO
	booking.room_type_inventory (
		hotel_id,
		room_type_id,
		date,
		total_inventory,
		total_reserved,
		updated_at,
		created_at
	)
SELECT
	$1,
	$2,
	unnest($3),
	$4,
	0,
	CURRENT_TIMESTAMP,
	CURRENT_TIMESTAMP
	--  simplification of a business rule to not handle constantly changing overcapacity issue-> e.g. some rolling update in the future is possible
	ON CONFLICT (hotel_id, room_type_id, date)
DO NOTHING
`

type BatchUpdateRoomTypeInventoryParams struct {
	HotelID        uuid.UUID   `json:"hotel_id"`
	RoomTypeID     uuid.UUID   `json:"room_type_id"`
	Dates          interface{} `json:"dates"`
	TotalInventory int32       `json:"total_inventory"`
}

func (q *Queries) BatchUpdateRoomTypeInventory(ctx context.Context, arg BatchUpdateRoomTypeInventoryParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, batchUpdateRoomTypeInventory,
		arg.HotelID,
		arg.RoomTypeID,
		arg.Dates,
		arg.TotalInventory,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getHotelInventoryForRange = `-- name: GetHotelInventoryForRange :many
SELECT
	hotel_id, room_type_id, date, updated_at, created_at, version, total_inventory, total_reserved
FROM
	booking.room_type_inventory
WHERE
	room_type_id = $1
	AND hotel_id = $2
	AND date BETWEEN $3 AND $4
`

type GetHotelInventoryForRangeParams struct {
	RoomTypeID uuid.UUID `json:"room_type_id"`
	HotelID    uuid.UUID `json:"hotel_id"`
	Date       time.Time `json:"date"`
	Date_2     time.Time `json:"date_2"`
}

func (q *Queries) GetHotelInventoryForRange(ctx context.Context, arg GetHotelInventoryForRangeParams) ([]BookingRoomTypeInventory, error) {
	rows, err := q.db.QueryContext(ctx, getHotelInventoryForRange,
		arg.RoomTypeID,
		arg.HotelID,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookingRoomTypeInventory
	for rows.Next() {
		var i BookingRoomTypeInventory
		if err := rows.Scan(
			&i.HotelID,
			&i.RoomTypeID,
			&i.Date,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.Version,
			&i.TotalInventory,
			&i.TotalReserved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomAvailabilityByDates = `-- name: GetRoomAvailabilityByDates :many
SELECT 
	rti.room_type_id,
	rt.name as room_type_name,
	rt.description,
	rti.date,
	(rti.total_inventory - rti.total_reserved) as available_capacity
FROM booking.room_type_inventory rti
INNER JOIN booking.room_types rt ON rti.room_type_id = rt.id
WHERE rti.hotel_id = $1
	AND rti.date BETWEEN $2 AND $3
	AND rti.total_reserved < (($4)::int * rti.total_inventory)
ORDER BY rt.name, rti.date
`

type GetRoomAvailabilityByDatesParams struct {
	HotelID     uuid.UUID `json:"hotel_id"`
	CheckIn     time.Time `json:"check_in"`
	CheckOut    time.Time `json:"check_out"`
	Overbooking int32     `json:"overbooking"`
}

type GetRoomAvailabilityByDatesRow struct {
	RoomTypeID        uuid.UUID      `json:"room_type_id"`
	RoomTypeName      string         `json:"room_type_name"`
	Description       sql.NullString `json:"description"`
	Date              time.Time      `json:"date"`
	AvailableCapacity int32          `json:"available_capacity"`
}

func (q *Queries) GetRoomAvailabilityByDates(ctx context.Context, arg GetRoomAvailabilityByDatesParams) ([]GetRoomAvailabilityByDatesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoomAvailabilityByDates,
		arg.HotelID,
		arg.CheckIn,
		arg.CheckOut,
		arg.Overbooking,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoomAvailabilityByDatesRow
	for rows.Next() {
		var i GetRoomAvailabilityByDatesRow
		if err := rows.Scan(
			&i.RoomTypeID,
			&i.RoomTypeName,
			&i.Description,
			&i.Date,
			&i.AvailableCapacity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoomTypeInventoryForDate = `-- name: UpdateRoomTypeInventoryForDate :execrows
UPDATE booking.room_type_inventory
SET
	total_reserved = total_reserved + $1,
	version = version + 1,
	updated_at = CURRENT_TIMESTAMP
WHERE
	room_type_id = $2
	AND hotel_id = $3
	AND date = $4
	AND version = $5
`

type UpdateRoomTypeInventoryForDateParams struct {
	TotalReserved int32     `json:"total_reserved"`
	RoomTypeID    uuid.UUID `json:"room_type_id"`
	HotelID       uuid.UUID `json:"hotel_id"`
	Date          time.Time `json:"date"`
	Version       int64     `json:"version"`
}

func (q *Queries) UpdateRoomTypeInventoryForDate(ctx context.Context, arg UpdateRoomTypeInventoryForDateParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateRoomTypeInventoryForDate,
		arg.TotalReserved,
		arg.RoomTypeID,
		arg.HotelID,
		arg.Date,
		arg.Version,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
